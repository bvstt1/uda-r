method = "BFGS")
rosenbrock <- function(x){
return(100 * (x[2] - x[1]^2)^2 + (1 - x[1]^2))
}
rosenbrock <- function(x){
return(100 * (x[2] - x[1]^2)^2 + (1 - x[1])^2)
}
x_inicial <- c(-1.2,1)
optim(par = x_inicial,
fn = rosenbrock,
method = "BFGS") #MALO
f <- function(x){
return((x[1] - 1)^2 + (x[2] - 2)^2)
}
grad_f <- function(x){
return(c(2 * (x[1] - 1), 2 * (x[2] - 2)))
}
x_inicial <- c(0,0)
optim(par = x_inicial,
fn = f,
gr = grad_f,
method = "BFGS")
f <- function(x){
return((x[1] - 1)^2 + (x[2] - 2)^2)
}
grad_f <- function(x){
return(c(2 * (x[1] - 1), 2 * (x[2] - 2)))
}
x_inicial <- c(0,0)
optim(par = x_inicial,
fn = f,
gr = grad_f,
method = "BFGS")
install.packages("optimx")
#cargar libreria
library(optimx)
install.packages("optimx")
install.packages(optimx)
install.packages(optimx)
installed.packages(optimx)
install.packages("optimx")
install.packages("optimx")
#cargar libreria
library(optimx)
optimx(par = x_inicial,
fn = f,
method = "L-BFGS-B",
lower = lim_inf,
upper = lim_sup)
install.packages("optimx")
#cargar libreria
library(optimx)
#cargar libreria
library(optimx)
# Función opbjetivo
f <- function(x){
return((x[1] - 2)^2 + (x[2] + 3)^2)
}
# Vector inicial
x_inicial <- c(1, -1)
# Función optimx
optimx(par = x_inicial,
fn = f,
method = "BFGS")
# Límites para las variables
lim_inf <- c(1, -5)
lim_sup <- c(3, -1)
optimx(par = x_inicial,
fn = f,
method = "L-BFGS-B",
lower = lim_inf,
upper = lim_sup)
lista_metodos <- c("Nedler-Mead",
"BGFS",
"CG",
"L-BFGD-B",
"nlmindb",
"Rcgmin",
"Rvmming")
f <- function (param){
x <- param[1]
y <- param[2]
20 + x^2 + y^2 - 10 * (cos(2 * pi * x) + cos(2 * pi * y))
}
# Definir gradiente y hessiana
library(Deriv)
grad_f <- Deriv(f, c("x", "y"))
hess_f <- Deriv(f, c("x", "y"), n = 2)
# Algoritmo Newton
newton <- function(x_actual, f, gradiente, hessiana,
tol = 1e-6,
max_iter = 100){
x_historia <- x_actual
f_historia <- f(x_actual)
converge = FALSE
for(i in 1:max_iter){
m_hess <- matrix(hessiana(x_actual),
nrow = 2,
byrow = TRUE)
eigen_valores <- eigen(m_hess)$values
if (any(eigen_valores <= 0)){
m_hess <- m_hess + abs(min(eigen_valores)) * diag(2)
}
x_nuevo <- x_actual - solve(m_hess) %*% gradiente(x_actual)
x_historia <- c(x_historia, x_nuevo)
f_historia <- c(f_historia, f(x_nuevo))
if (norm(gradiente(x_nuevo), "2") < tol){
converge <- TRUE
break
}
x_actual <- x_nuevo
}
resultado <- data.frame(x = matrix(x_historia, ncol = 2, byrow = TRUE),
f = f_historia)
colnames(resultado) <- c("x", "y", "f")
return(list(converge = converge,
resultado = resultado))
}
x_0 <- c(20, 20)
newton(x_0, f, grad_f, hess_f)
# Análisis del dominio de la función
#-----------------------------------
f_g <- function(x, y){
20 + x^2 + y^2 - 10 * (cos(2 * pi * x) + cos(2 * pi * y))
}
x <- y <- seq(-5,5,length.out = 100)
z <- outer(x,y,f_g)
persp(x, y, z, theta = 45, phi = 45, col ="lightblue")
contour(x, y, z, nlevels = 20)
# GRID - SEARCH
# -------------
n_puntos <- 100
x1 <- y1 <- seq(-5, 5, length.out = n_puntos)
contour(x,y,z, nlevels = 20)
abline(v = x1, h = y1, col="green")
grid_puntos <- expand.grid(x1, y1)
contour(x,y,z,nlevels = 20)
points(grid_puntos, col = "green", pch = 19)
grid_valores <- numeric(nrow(grid_puntos))
for (i in 1:nrow(grid_puntos)){
grid_valores[i] <- f(c(grid_puntos$Var1[i],
grid_puntos$Var2[i]))
}
index_ordenados <- order(grid_valores)
mejores_puntos <- grid_puntos[index_ordenados[1:10],]
mejores_valores <- grid_valores[index_ordenados[1:10]]
list(mejores_puntos = mejores_puntos,
mejores_valores = mejores_valores)
points(mejores_puntos, col = "red", pch = 19)
newton(c(0.05050505, 0.05050505), f, grad_f, hess_f)
points(0, 0, col = "red", pch = 19)
points(grid_puntos, col = "green", pch = 19)
optimx(par = x_inicial,
fn = f,
method = lista_metodos)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
x_inicial <- c(4, 4)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
optimx(par = x_inicial,
fn = f,
method = lista_metodos)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
contour(x, y, z, nlevels = 20)
x_inicial <- c(4, 4)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
optimx(par = x_inicial,
fn = f,
method = lista_metodos)
contour(x, y, z, nlevels = 10)
par(mar = c(4,4,1,1))
x_inicial <- c(4, 4)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
optimx(par = x_inicial,
fn = f,
method = lista_metodos)
par(mar = c(4,4,1,1))
contour(x, y, z, nlevels = 10)
points(x_inicial[1], x_inicial[2],
pch = 20, col="red")
points(res$p1, res$p2,
pch = 20, col ="green")
res <- optimx(par = x_inicial,
fn = f,
method = lista_metodos)
points(res$p1, res$p2,
pch = 20, col ="green")
points
# Rango
range(salario_mensual[genero == "Masculino"])
library(readxl)
setwd("/home/miitsuki/Escritorio/Proyectos/UDA - r/formacion 3")
bd_programadores <- read_excel("bd_programadores.xlsx")
str(bd_programadores)
salario_mensual <- bd_programadores$salario_mensual
genero <- bd_programadores$genero
# Media por genero
media_f <- mean(salario_mensual[genero == "Femenino"])
media_m <- mean(salario_mensual[genero == "Masculino"])
# Mediana por genero
mediana_f <- median(salario_mensual[genero == "Femenino"])
mediana_m <- median(salario_mensual[genero == "Masculino"])
cat("Masculino - Media:", media_m, "Mediana:", mediana_m, "\n")
cat("Femenino - Media:", media_f, "Mediana:", mediana_f, "\n")
x11()
boxplot(salario_mensual ~ genero,
main = "Distribución del salario mensual por género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("lightblue", "pink", "purple"))
# Desviación estandar por genero
desv_m <- sd(salario_mensual[genero == "Masculino"])
desv_f <- sd(salario_mensual[genero == "Femenino"])
# Rango
range(salario_mensual[genero == "Masculino"])
range(salario_mensual[genero == "Femenino"])
# Rango
range(salario_mensual[genero == "Masculino"])
range(salario_mensual[genero == "Femenino"])
# Desviación estandar por genero
desv_m <- sd(salario_mensual[genero == "Masculino"])
desv_f <- sd(salario_mensual[genero == "Femenino"])
desv_m
desv_f
# Varianza
var(salario_mensual[genero == "Masculino"])
var(salario_mensual[genero == "Femenino"])
hist(salario_mensual[genero == "Masculino"])
x11()
hist(salario_mensual[genero == "Masculino"])
hist(salario_mensual[genero == "Femenino"])
x11()
hist(salario_mensual[genero == "Masculino"])
hist(salario_mensual[genero == "Femenino"])
library(ggplot2)
ggplot(bd_programadores, aes(x = salario_mensual, fill = genero)) +
geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
facet_wrap(~ genero) +
labs(title = "Histograma de salario mensual por género",
x = "Salario mensual (CLP)", y = "Frecuencia") +
theme_minimal()
range(salario_mensual[genero == "Femenino"])
# Rango
range(salario_mensual[genero == "Masculino"])
# Varianza
var(salario_mensual[genero == "Masculino"])
var(salario_mensual[genero == "Femenino"])
x11()
boxplot(salario_mensual ~ genero,
main = "Distribución del salario mensual por género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("lightblue", "pink", "purple"))
boxplot(salario_mensual ~ genero,
main = "Distribución del salario mensual por género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("pink", "lightblue", "purple"))
media_m <- mean(salario_mensual[genero == "Masculino"])
media_m
media_f
cat("Masculino - Media:", media_m, "Mediana:", mediana_m, "\n")
cat("Femenino - Media:", media_f, "Mediana:", mediana_f, "\n")
range(salario_mensual[genero == "Femenino"])
# Rango
range(salario_mensual[genero == "Masculino"])
nivel_educativo <- bd_programadores$nivel_educativo
media_edu <- mean(nivel_educativo)
media_edu <- mean(salario_mensual[nivel_educativo])
media_edu
media_edu <- mean(salario_mensual[nivel_educativo])
media_edu
nivel_educativo
media_edu <- tapply(salario_mensual, bd_programadores$nivel_educativo, mean)
media_edu
media_edu <- mean(salario_mensual~nivel_educativo)
media_edu
media_edu <- tapply(salario_mensual, nivel_educativo, mean)
media_edu
nivel_educativo <- bd_programadores$nivel_educativo
lenguaje_preferido <- bd_programadores$lenguaje_preferido
media_edu <- tapply(salario_mensual, nivel_educativo, mean)
mediana_leng <- tapply(salario_mensual, lenguaje_preferido, median)
mediana_leng
desv_leng <- tapply(salario_mensual, lenguaje_preferido, sd)
desv_leng
desv_edu <- tapply(salario_mensual, lenguaje_preferido, sd)
mediana_edu <- tapply(salario_mensual, nivel_educativo, median)
media_edu <- tapply(salario_mensual, nivel_educativo, mean)
mediana_edu <- tapply(salario_mensual, nivel_educativo, median)
desv_edu <- tapply(salario_mensual, lenguaje_preferido, sd)
media_edu
mediana_edu
desv_edu
desv_edu <- tapply(salario_mensual, nivel_educativo, sd)
desv_edu
# Boxplot por lenguaje
boxplot(salario_mensual ~ lenguaje_preferido,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
x11()
# Boxplot por lenguaje
boxplot(salario_mensual ~ lenguaje_preferido,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Histograma por lenguaje
ggplot(bd_programadores, aes(x = salario_mensual, fill = lenguaje_preferido)) +
geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
facet_wrap(~ lenguaje_preferido) +
labs(title = "Histograma de salario mensual por lenguaje preferido",
x = "Salario mensual (CLP)", y = "Frecuencia") +
theme_minimal()
# Boxplot por lenguaje
boxplot(salario_mensual ~ nivel_educativo,
data = bd_programadores,
main = "Salario mensual según Nivel Educativo",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Histograma por lenguaje
ggplot(bd_programadores, aes(x = salario_mensual, fill = nivel_educativo)) +
geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
facet_wrap(~ nivel_educativo) +
labs(title = "Histograma de salario mensual por Nivel Educativo",
x = "Salario mensual (CLP)", y = "Frecuencia") +
theme_minimal()
x11()
# Boxplot por lenguaje
boxplot(salario_mensual ~ nivel_educativo,
data = bd_programadores,
main = "Salario mensual según Nivel Educativo",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Boxplot por lenguaje
boxplot(salario_mensual ~ nivel_educativo,
data = bd_programadores,
main = "Salario mensual según Nivel Educativo",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Histograma por lenguaje
ggplot(bd_programadores, aes(x = salario_mensual, fill = nivel_educativo)) +
geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
facet_wrap(~ nivel_educativo) +
labs(title = "Histograma de salario mensual por Nivel Educativo",
x = "Salario mensual (CLP)", y = "Frecuencia") +
theme_minimal()
desv_edu <- tapply(salario_mensual, nivel_educativo, sd)
mediana_edu <- tapply(salario_mensual, nivel_educativo, median)
media_edu <- tapply(salario_mensual, nivel_educativo, mean)
media_edu
mediana_edu
desv_edu
media_edu <- tapply(salario_mensual, nivel_educativo, mean)
media_edu
media_edu
bd_programadores
View(bd_programadores)
nivel_educativo
media_edu
media_leng
media_leng <- tapply(salario_mensual, bd_programadores$lenguaje_preferido, mean)
mediana_leng <- tapply(salario_mensual, bd_programadores$lenguaje_preferido, median)
desv_leng <- tapply(salario_mensual, bd_programadores$lenguaje_preferido, sd)
# Boxplot por lenguaje
boxplot(salario_mensual ~ lenguaje_preferido,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)  # las = 2 para girar etiquetas si son largas
# Histograma por lenguaje
ggplot(bd_programadores, aes(x = salario_mensual, fill = lenguaje_preferido)) +
geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
facet_wrap(~ lenguaje_preferido) +
labs(title = "Histograma de salario mensual por lenguaje preferido",
x = "Salario mensual (CLP)", y = "Frecuencia") +
theme_minimal()
s
media_leng
mediana_leng
desv_leng
boxplot(salario_mensual ~ lenguaje_preferido,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
boxplot(lenguaje_preferido ~ salario_mensual,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Boxplot por lenguaje
boxplot(lenguaje_preferido ~ salario_mensual,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)
# Boxplot por lenguaje
boxplot(lenguaje_preferido ~ salario_mensual,
data = bd_programadores,
main = "Salario mensual según lenguaje preferido",
xlab = "Lenguaje de programación", ylab = "Salario mensual (CLP)",
col = "lightblue", las = 2)  # las = 2 para girar etiquetas si son largas
# Calcular media y desviación estándar
media <- mean(bd_programadores$salario_mensual)
desv <- sd(bd_programadores$salario_mensual)
# Regla empírica: porcentajes esperados si distribución es normal
# ±1 sd: ~68%, ±2 sd: ~95%, ±3 sd: ~99.7%
emp_1 <- mean(bd_programadores$salario_mensual >= (media - 1*desv) & bd_programadores$salario_mensual <= (media + 1*desv))
emp_2 <- mean(bd_programadores$salario_mensual >= (media - 2*desv) & bd_programadores$salario_mensual <= (media + 2*desv))
emp_3 <- mean(bd_programadores$salario_mensual >= (media - 3*desv) & bd_programadores$salario_mensual <= (media + 3*desv))
# Chebyshev (para cualquier distribución): mínimo esperado
# k = 2 → 1 - 1/4 = 75%
# k = 3 → 1 - 1/9 ≈ 88.89%
cheb_2 <- emp_2 >= 0.75
cheb_3 <- emp_3 >= 0.8889
# Mostrar resultados
cat("FRECUENCIAS OBSERVADAS:\n")
cat("±1 desviación:", round(emp_1 * 100, 2), "%\n")
cat("±2 desviaciones:", round(emp_2 * 100, 2), "% →", ifelse(cheb_2, "Cumple Chebyshev", "No cumple"), "\n")
cat("±3 desviaciones:", round(emp_3 * 100, 2), "% →", ifelse(cheb_3, "Cumple Chebyshev", "No cumple"), "\n")
cat("±1 desviación:", round(emp_1 * 100, 2), "%\n")
cat("±2 desviaciones:", round(emp_2 * 100, 2), "% →", ifelse(cheb_2, "Cumple Chebyshev", "No cumple"), "\n")
cat("±3 desviaciones:", round(emp_3 * 100, 2), "% →", ifelse(cheb_3, "Cumple Chebyshev", "No cumple"), "\n")
# Mostrar resultados
cat("FRECUENCIAS OBSERVADAS:\n")
cat("±1 desviación:", round(emp_1 * 100, 2), "%\n")
cat("±2 desviaciones:", round(emp_2 * 100, 2), "% →", ifelse(cheb_2, "Cumple Chebyshev", "No cumple"), "\n")
cat("±3 desviaciones:", round(emp_3 * 100, 2), "% →", ifelse(cheb_3, "Cumple Chebyshev", "No cumple"), "\n")
desv <- sd(salario_mensual)
# Calcular media y desviación estándar
media <- mean(salario_mensual)
emp_1
emp_2
emp_3
cat("±1 desviación:", round(emp_1 * 100, 2), "%\n")
# Chebyshev (para cualquier distribución): mínimo esperado
# k = 2 → 1 - 1/4 = 75%
# k = 3 → 1 - 1/9 ≈ 88.89%
cheb_2 <- emp_2 >= 0.75
cheb_2
cheb_3
# Calcular media y desviación estándar
media <- mean(salario_mensual)
cat("±1 desviación:", round(emp_1 * 100, 2), "%\n")
emp_1
boxplot(salario_mensual ~ genero,
data = bd_programadores,
main = "Salario mensual según género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("lightblue", "pink"))
x11()
boxplot(salario_mensual ~ genero,
data = bd_programadores,
main = "Salario mensual según género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("lightblue", "pink"))
boxplot(salario_mensual ~ genero,
data = bd_programadores,
main = "Salario mensual según género",
xlab = "Género", ylab = "Salario mensual (CLP)",
col = c("pink", "lightblue"))
# Seleccionar solo variables cuantitativas
cuantitativas <- bd_programadores[, c("edad", "horas_trabajo_semanal", "proyectos_realizados", "salario_mensual")]
# Matriz de correlaciones
correlaciones <- cor(cuantitativas)
# Ver matriz
print(round(correlaciones, 2))
library(corrplot)
library(corrplot)
install.packages("corrplot")
library(corrplot)
corrplot(correlaciones, method = "color", type = "upper",
tl.col = "black", addCoef.col = "black", number.cex = 0.8)
# Pares donde podrías esperar relación: por ejemplo, salario vs horas trabajadas
plot(bd_programadores$horas_trabajo_semanal, bd_programadores$salario_mensual,
main = "Relación entre horas semanales y salario",
xlab = "Horas de trabajo semanal", ylab = "Salario mensual (CLP)",
col = "blue", pch = 19)
# También puedes probar salario vs experiencia
plot(bd_programadores$proyectos_realizados, bd_programadores$salario_mensual,
main = "Relación entre proyectos realizados y salario",
xlab = "Proyectos realizados", ylab = "Salario mensual (CLP)",
col = "darkgreen", pch = 19)
# Pares donde podrías esperar relación: por ejemplo, salario vs horas trabajadas
plot(bd_programadores$horas_trabajo_semanal, bd_programadores$salario_mensual,
main = "Relación entre horas semanales y salario",
xlab = "Horas de trabajo semanal", ylab = "Salario mensual (CLP)",
col = "blue", pch = 19)
minerales <- read.table("minerales.txt", header = TRUE)
minerales <- read.table("minerales.txt", header = TRUE)
minerales <- read.table("minerales.txt", header = TRUE)
minerales
# Ver estructura
str(minerales)
# Calcular la media de cada columna (cada mineral)
medias <- colMeans(minerales)
medias
# Ordenar de mayor a menor
medias_ordenadas <- sort(medias, decreasing = TRUE)
medias_ordenadas <- sort(medias, decreasing = TRUE)
medias_ordenadas
# Mostrar resultado
print(round(medias_ordenadas, 2))
max(medias)
maximo <- medias[which.max(medias)]
maximo
GIT INIT
git init
